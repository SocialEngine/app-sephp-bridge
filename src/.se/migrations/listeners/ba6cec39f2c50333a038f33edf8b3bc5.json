{
    "code": "const app = require('app');\n\nconst validMigrations = [\n    'users'\n];\n\nasync function apiRequest (endpoint, query = {}) {\n    const url = await app.data.get('sephp:url');\n    const token = await app.data.get('sephp:token');\n    let search = '';\n    let iteration = 0;\n    for (const key of Object.keys(query)) {\n        iteration++;\n        if (iteration !== 1) {\n            search += '&';\n        }\n        search += key + '=' + query[key];\n    }\n    if (search) {\n        search = '?' + search;\n    }\n    const request = await app.fetch(url + '/bridge/migrations' + endpoint + search, {\n        headers: {\n            'SE-Unite-Token': token\n        }\n    });\n    return request.json();\n}\n\nfunction startMigration (type, cb, limit = 2) {\n    return new Promise(async function (resolve) {\n        const migration = await getMigration(type);\n        const start = async function request (page) {\n            const response = await apiRequest('/' + type, {\n                page: page,\n                limit: limit\n            });\n            await setMigration(type, 'total', response.total);\n            await setMigration(type, 'page', page);\n            app.websocket.send(migration.socketId, {\n                page: page,\n                total: response.total,\n                migration: await getMigration(type)\n            });\n            for (const record of response.records) {\n                await cb(record)\n                    .catch(e => {\n                        console.log('error:', e);\n                    })\n            }\n            if (response.records.length) {\n                return request((page + 1));\n            } else {\n                resolve();\n            }\n        };\n        return start(1);\n    });\n}\n\nasync function setMigration (type, key, value) {\n    await app.data.set('sephp:migration:' + type + ':' + key, value);\n}\n\nasync function delMigration (type, key) {\n    await app.data.del('sephp:migration:' + type + ':' + key);\n}\n\nasync function getMigration (type) {\n    const migration = {\n        id: type,\n        name: type\n    };\n    const keys = [\n        'started',\n        'socketId',\n        'completed',\n        'failed',\n        'total',\n        'page'\n    ];\n    for (const key of keys) {\n        migration[key] = await app.data.get('sephp:migration:' + type + ':' + key);\n    }\n    return migration;\n}\n\nconst handleMigration = {\n    users: async function (record) {\n        let user = await app.api.users.findByEmail(record.email);\n        if (!user) {\n            if (!record.photo) {\n                record.photo = '';\n            } else {\n                record.photo = 'sephp:' + record.photo;\n            }\n            let group = 'member';\n            switch (record.groups) {\n                case 'admin':\n                    group = 'owner';\n                    break;\n                case 'moderator':\n                    group = 'admin';\n                    break;\n            }\n            record.groups = [group];\n            record.agree = true;\n            user = await app.api.users.create(record);\n        }\n        await setMigration('users', 'reverse:' + record.id, user.id);\n        await setMigration('users', 'data:' + user.id, JSON.stringify({\n            user_id: record.id\n        }));\n        console.log('user:', user.id);\n    }\n};\n\nmodule.exports = async function ({router}) {\n    router.put('/users/:id', async function (req, res) {\n        await app.api.adminsOnly();\n        res({\n            id: req.get(':id'),\n            hello: await app.module.updateUser(req.get(':id'), {\n                user_id: req.get('se_user_id')\n            })\n        });\n    });\n\n    router.get('/connect/:auth', async function (req, res) {\n        await app.api.adminsOnly();\n\n        let url = req.get('return');\n        url = url.replace('/admin/unite-bridge/manage', '');\n        const apiKey = await app.site.generateNewApiKey();\n        const viewerApiToken = await app.api.users.generateApiToken(\n            app.viewer.id\n        );\n        const request = await app.fetch(url + '/bridge/connect', {\n                method: 'POST',\n                body: JSON.stringify({\n                    auth: req.get(':auth'),\n                    apiKey: apiKey.publicKey + ':' + apiKey.privateKey,\n                    viewerToken: viewerApiToken.token,\n                    siteId: app.site.id()\n                }),\n                headers: {\n                    'Content-Type': 'application/json'\n                }\n            }\n        );\n        const data = await request.json();\n        if (data.error !== undefined) {\n            res(data);\n        } else {\n            await app.data.set('sephp:auth', req.get(':auth'));\n            await app.data.set('sephp:token', data.token);\n            await app.data.set('sephp:url', url);\n            res({\n                success: true\n            });\n        }\n    });\n\n    router.get('/migrations', async function (req, res) {\n        const migrations = [];\n        for (const type of validMigrations) {\n            const migration = await getMigration(type);\n            migrations.push(migration);\n        }\n        res({\n            records: migrations\n        });\n    });\n\n    router.post('/migrations/:type', async function (req, res) {\n        await app.api.adminsOnly();\n        const type = req.get(':type');\n\n        if (!validMigrations.includes(type)) {\n            app.error('Not a valid migration');\n        }\n\n        const socketId = app.utility.str.random(32);\n\n        await setMigration(type, 'started', app.now());\n        await setMigration(type, 'socketId', socketId);\n        await delMigration(type, 'completed');\n        await delMigration(type, 'page');\n        await delMigration(type, 'total');\n\n        const migration = await getMigration(type);\n        startMigration(type, handleMigration[type], req.get('limit', 100))\n            .then(async () => {\n                await setMigration(type, 'completed', app.now());\n                app.websocket.send(migration.socketId, {\n                    page: 0,\n                    total: 0,\n                    migration: await getMigration(type)\n                });\n            })\n            .catch(async e => {\n                await setMigration(type, 'failed', e.message);\n            });\n\n        res(migration);\n    });\n\n    router.get('/sso', async function (req, res) {\n        const token = req.get('token');\n        if (!token) {\n            app.error('Missing auth token');\n        }\n        const tokenKey = 'auth:token:' + token;\n        let data = await app.data.get(tokenKey);\n        if (!data) {\n            app.error('Not a valid token.');\n        }\n        await app.data.del(tokenKey);\n        data = JSON.parse(data);\n        res({\n            data: data\n        });\n    });\n\n    router.post('/sso', async function (req, res) {\n        await app.api.viewerOnly();\n        const viewer = app.viewer;\n        if (!viewer) {\n            app.error('Need to be logged in.');\n        }\n        const token = app.utility.str.random(128);\n        const user = await app.module.getUser(viewer.id);\n        const url = await app.module.getUrl();\n        const tokenKey = 'auth:token:' + token;\n        app.data.set(tokenKey, JSON.stringify({\n            uniteUserId: viewer.id,\n            viewer: await app.api.users.read(viewer.id, {\n                include: 'email'\n            }),\n            sephpUserId: user ? user.user_id : null\n        }));\n        app.data.expire(tokenKey, 300);\n        res({\n            url: url + '/bridge/sso?token=' + token\n        });\n    });\n};\n",
    "events": [
        "APIRouter:match"
    ],
    "version": "1.0.6"
}